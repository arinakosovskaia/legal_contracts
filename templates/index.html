<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Contract Red-Flag Detector (Demo)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      .row { display: flex; gap: 24px; align-items: flex-start; flex-wrap: wrap; }
      .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; max-width: 1100px; }
      .muted { color: #666; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border: 1px solid #eee; padding: 8px; vertical-align: top; }
      th { background: #fafafa; position: sticky; top: 0; }
      .badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #ccc; }
      .high { background: #ffe5e5; border-color: #ffb3b3; }
      .medium { background: #fff0d6; border-color: #ffd399; }
      .low { background: #e9f6ff; border-color: #b3dcff; }
      pre { white-space: pre-wrap; word-break: break-word; }
      button { cursor: pointer; }
    </style>
  </head>
  <body>
    <h2>Contract Red-Flag Detector (Demo)</h2>
    <p class="muted">Upload a PDF. Enter your API key (Nebius/OpenAI) and choose a model. The backend parses into sections + sliding windows and runs a red-flag classifier with CUAD-based few-shot examples.</p>

    <div class="card" style="margin-bottom: 24px;">
      <h3>How to use (demo)</h3>
      <ol>
        <li>Click <b>Choose file</b> and select a PDF contract.</li>
        <li>Click <b>Upload & Analyze</b>.</li>
        <li>Wait until status becomes <b>done</b>. The table will appear automatically.</li>
        <li>Click <b>Download JSON</b> to export the result.</li>
      </ol>
      <p class="muted">
        Limits are configurable via <code>.env</code> (pages/paragraphs/file size). If the PDF exceeds limits, you will get a clear error.
      </p>
      <p class="muted">
        API endpoints: <code>POST /upload</code>, <code>GET /job/&lt;id&gt;</code>, <code>GET /job/&lt;id&gt;/result</code>.
      </p>
    </div>

    <div class="row">
      <div class="card">
        <h3>Upload</h3>
        <form id="uploadForm">
          <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <div>
              <div class="muted" style="font-size:12px;">Provider</div>
              <select id="provider" name="provider">
                <option value="nebius" selected>Nebius (TokenFactory)</option>
                <option value="openai">OpenAI</option>
              </select>
            </div>
            <div>
              <div class="muted" style="font-size:12px;">Model</div>
              <select id="model" name="model"></select>
            </div>
            <div>
              <div class="muted" style="font-size:12px;">Custom model (optional)</div>
              <input id="modelCustom" type="text" placeholder="(optional) override selected model" style="min-width:420px;" />
            </div>
          </div>

          <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <div>
              <div class="muted" style="font-size:12px;">API key (not stored)</div>
              <input id="apiKey" name="api_key" type="password" placeholder="Paste key here" style="min-width:420px;" />
            </div>
            <div id="baseUrlBox">
              <div class="muted" style="font-size:12px;">Base URL (Nebius)</div>
              <input id="baseUrl" name="base_url" type="text" value="https://api.tokenfactory.nebius.com/v1/" style="min-width:420px;" />
            </div>
          </div>

          <div style="margin-bottom:10px;">
            <label class="muted" style="display:flex; gap:8px; align-items:center;">
              <input id="enableDebugParagraph" type="checkbox" />
              Debug per paragraph (parser output + section path)
            </label>
            <label class="muted" style="display:flex; gap:8px; align-items:center; margin-top:6px;">
              <input id="enableDebugWindow" type="checkbox" />
              Debug per window (LLM prompts + outputs + live trace). May include document text.
            </label>
          </div>

          <input type="file" id="pdfFile" name="file" accept="application/pdf" required />
          <button type="submit">Upload & Analyze</button>
        </form>
        <p id="jobInfo" class="muted"></p>
        <p id="jobStatus"></p>
        <progress id="jobProgress" value="0" max="100" style="width: 100%; display: none;"></progress>
        <div id="liveTrace" class="card" style="display:none; margin-top: 12px;">
          <h3>Live trace (current LLM window)</h3>
          <p class="muted">This updates during processing and replaces the previous trace. Enable by checking <b>Debug per window</b> before upload.</p>
          <div id="liveTraceBox"></div>
        </div>
        <p>
          <button id="downloadBtn" disabled>Download JSON</button>
          <button id="cancelBtn" disabled style="margin-left:8px;">Stop</button>
        </p>
      </div>
    </div>

    <div id="result" class="card" style="display:none; margin-top: 24px;">
      <h3>Summary</h3>
      <pre id="summary"></pre>
      <h3>Findings</h3>
      <div style="max-height: 560px; overflow: auto;">
        <table id="findingsTable">
          <thead>
            <tr>
              <th>Severity</th>
              <th>Category</th>
              <th>Confidence</th>
              <th>Issue</th>
              <th>What is wrong</th>
              <th>Recommendation</th>
              <th>Evidence</th>
              <th>Location</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="debug" style="display:none; margin-top: 24px;">
        <h3>Debug traces</h3>
        <p class="muted">Enabled only if you checked <b>Debug per paragraph</b> and/or <b>Debug per window</b> before upload. This may include document text.</p>
        <div id="debugTraces"></div>
        <div id="debugWindows" style="margin-top:16px;"></div>
      </div>
    </div>

    <script>
      let currentJobId = null;
      let pollTimer = null;

      function el(id) { return document.getElementById(id); }

      function setStatus(text) {
        el("jobStatus").textContent = text;
      }

      async function uploadPdf(file) {
        const fd = new FormData();
        fd.append("file", file);
        const provider = (el("provider")?.value || "nebius");
        const apiKey = (el("apiKey")?.value || "");
        const baseUrl = (el("baseUrl")?.value || "");
        const modelSel = (el("model")?.value || "");
        const modelCustom = (el("modelCustom")?.value || "");
        const model = modelCustom.trim() ? modelCustom.trim() : modelSel;
        fd.append("provider", provider);
        fd.append("api_key", apiKey);
        fd.append("base_url", baseUrl);
        fd.append("model", model);
        fd.append("enable_debug_paragraph", el("enableDebugParagraph")?.checked ? "1" : "0");
        fd.append("enable_debug_window", el("enableDebugWindow")?.checked ? "1" : "0");
        const res = await fetch("/upload", { method: "POST", body: fd });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || data.error || "Upload failed");
        return data;
      }

      async function fetchJob(jobId) {
        const res = await fetch(`/job/${jobId}`);
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || data.error || "Job fetch failed");
        return data;
      }

      async function fetchResult(jobId) {
        const res = await fetch(`/job/${jobId}/result`);
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || data.error || "Result fetch failed");
        return data;
      }

      async function cancelJob(jobId) {
        const res = await fetch(`/job/${jobId}/cancel`, { method: "POST" });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || data.error || "Cancel failed");
        return data;
      }

      async function fetchLiveTrace(jobId) {
        const res = await fetch(`/job/${jobId}/live-trace`);
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || data.error || "Live trace fetch failed");
        return data;
      }

      function renderLiveTrace(trace) {
        const box = el("liveTraceBox");
        if (!trace) {
          box.innerHTML = "";
          return;
        }
        const status = trace.processing ? "processing…" : "done";
        const phase = trace.phase || "";
        const ctx = trace.context_prefix || trace.section_path || "";
        const chunk = trace.text_chunk || "";
        const fewshot = trace.fewshot || "";
        const defs = trace.category_definitions || "";
        const parsed = trace.parsed ? JSON.stringify(trace.parsed, null, 2) : "";
        const raw = trace.raw_output || "";

        box.innerHTML = `
          <div class="muted" style="margin-bottom:8px;"><b>Status:</b> ${escapeHtml(status)} <span class="muted">(phase=${escapeHtml(phase)})</span></div>
          <details open style="margin: 6px 0;">
            <summary><b>CONTEXT PREFIX</b></summary>
            <pre>${escapeHtml(ctx)}</pre>
          </details>
          <details open style="margin: 6px 0;">
            <summary><b>TEXT CHUNK</b></summary>
            <pre>${escapeHtml(chunk)}</pre>
          </details>
          <details style="margin: 6px 0;">
            <summary><b>CATEGORY DEFINITIONS</b></summary>
            <pre>${escapeHtml(defs)}</pre>
          </details>
          <details style="margin: 6px 0;">
            <summary><b>FEW-SHOT</b> <span class="muted">(from CUAD_v1.json)</span></summary>
            <pre>${escapeHtml(fewshot || "(none)")}</pre>
          </details>
          ${parsed ? `
            <details open style="margin: 6px 0;">
              <summary><b>MODEL OUTPUT (parsed)</b></summary>
              <pre>${escapeHtml(parsed)}</pre>
            </details>
          ` : ""}
          ${raw ? `
            <details style="margin: 6px 0;">
              <summary><b>MODEL OUTPUT (raw)</b></summary>
              <pre>${escapeHtml(raw)}</pre>
            </details>
          ` : ""}
        `;
      }

      function renderResult(result) {
        el("result").style.display = "block";
        el("summary").textContent = JSON.stringify(result.summary, null, 2);

        const tbody = el("findingsTable").querySelector("tbody");
        tbody.innerHTML = "";
        for (const f of result.findings || []) {
          const tr = document.createElement("tr");
          const sev = (f.severity || "low").toLowerCase();
          tr.innerHTML = `
            <td><span class="badge ${sev}">${sev}</span></td>
            <td>${escapeHtml(f.category_name || f.category_id || "")}</td>
            <td>${formatPercent(f.confidence)}</td>
            <td>${escapeHtml(f.issue_title || "")}</td>
            <td>${escapeHtml(f.what_is_wrong || "")}</td>
            <td>${escapeHtml(f.recommendation || "")}</td>
            <td><pre>${escapeHtml(f.evidence_quote || "")}</pre></td>
            <td>p.${f.location?.page ?? "?"}, ¶${f.location?.paragraph_index ?? "?"}</td>
          `;
          tbody.appendChild(tr);
        }

        const traces = result?.meta?.debug?.paragraph_traces || null;
        const windows = result?.meta?.debug?.window_traces || null;
        const dbg = el("debug");
        const dbgBox = el("debugTraces");
        const dbgWin = el("debugWindows");
        if (Array.isArray(traces) && traces.length) {
          dbg.style.display = "block";
          dbgBox.innerHTML = "";
          for (const t of traces) {
            const details = document.createElement("details");
            details.style.margin = "10px 0";
            const s1 = t.stage1 ? JSON.stringify(t.stage1, null, 2) : "";
            const runs = Array.isArray(t.stage2_runs) ? t.stage2_runs : [];
            const kind = t.kind || "paragraph";
            const skipBadge = (kind === "heading") ? " — SKIP: heading-only" : "";
            details.innerHTML = `
              <summary>p.${t.page}, ¶${t.paragraph_index} (${escapeHtml(kind)})${escapeHtml(skipBadge)} — ${escapeHtml(t.section_path || "")} — stage1_error=${escapeHtml(t.stage1_error ?? "null")} stage2_error=${escapeHtml(t.stage2_error ?? "null")}</summary>
              <div style="margin-top: 8px;">
                <div><b>Section path</b></div>
                <pre>${escapeHtml(t.section_path || "")}</pre>
                <div><b>Paragraph text</b></div>
                <pre>${escapeHtml(t.paragraph_text || "")}</pre>
                ${t.kind === "heading" ? `
                  <div><b>Note</b></div>
                  <pre>${escapeHtml(t.note || "Heading-only paragraph. Nothing to classify.")}</pre>
                ` : ""}
                <div><b>Covered by windows</b> <span class="muted">(LLM runs per window; prompts are shown below in "per window")</span></div>
                <pre>${escapeHtml(JSON.stringify(t.covered_by_windows || [], null, 2))}</pre>
                <div><b>Stage1 parsed</b></div>
                <pre>${escapeHtml(s1)}</pre>
                <div><b>Stage1 raw</b></div>
                <pre>${escapeHtml(t.stage1_raw || "")}</pre>
                <div><b>Stage2 runs (${runs.length})</b></div>
                ${runs.map(r => `
                  <details style="margin: 6px 0 0 0;">
                    <summary>category_id=${escapeHtml(r.category_id || "")} stage2_error=${escapeHtml(r.stage2_error ?? "null")}</summary>
                    <div style="margin-top: 6px;">
                      <div><b>Stage1 (this category)</b></div>
                      <pre>${escapeHtml(JSON.stringify(r.stage1 || {}, null, 2))}</pre>
                      <div><b>Stage2 parsed</b></div>
                      <pre>${escapeHtml(JSON.stringify(r.stage2 || {}, null, 2))}</pre>
                      <div><b>Stage2 raw</b></div>
                      <pre>${escapeHtml(r.stage2_raw || "")}</pre>
                    </div>
                  </details>
                `).join("")}
              </div>
            `;
            dbgBox.appendChild(details);
          }
        } else {
          dbgBox.innerHTML = "";
        }

        if (Array.isArray(windows) && windows.length) {
          dbg.style.display = "block";
          dbgWin.innerHTML = "<h3>Debug traces (per window)</h3>";
          for (const w of windows) {
            const d = document.createElement("details");
            d.style.margin = "10px 0";
            d.innerHTML = `
              <summary>${escapeHtml(w.window_id || "")} — ${escapeHtml(w.section_path || "")} — paragraphs=${escapeHtml(JSON.stringify(w.paragraph_indices || []))}</summary>
              <div style="margin-top: 8px;">
                <div><b>Parsed</b></div>
                <pre>${escapeHtml(JSON.stringify(w.parsed || {}, null, 2))}</pre>
                <div><b>Final prompt (system)</b></div>
                <pre>${escapeHtml(w.prompt_system || "")}</pre>
                <div><b>Final prompt (user)</b> <span class="muted">(len=${escapeHtml(w.prompt_user_len ?? "?")})</span></div>
                <div class="muted" style="font-size:12px;">Head</div>
                <pre>${escapeHtml(w.prompt_user_head || "")}</pre>
                <div class="muted" style="font-size:12px;">Tail</div>
                <pre>${escapeHtml(w.prompt_user_tail || "")}</pre>
                <div><b>Raw output</b></div>
                <pre>${escapeHtml(w.raw_output || "")}</pre>
                <div><b>TEXT CHUNK (truncated)</b></div>
                <pre>${escapeHtml(w.text_chunk || "")}</pre>
                <div><b>TEXT CHUNK raw (before cleanup)</b></div>
                <pre>${escapeHtml(w.text_chunk_raw || "")}</pre>
              </div>
            `;
            dbgWin.appendChild(d);
          }
        } else {
          dbgWin.innerHTML = "";
          if (!(Array.isArray(traces) && traces.length)) {
            dbg.style.display = "none";
          }
        }
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function formatPercent(x) {
        const n = Number(x ?? 0);
        if (!Number.isFinite(n)) return "";
        return `${Math.round(n * 100)}%`;
      }

      function startPolling(jobId) {
        if (pollTimer) clearInterval(pollTimer);
        el("jobProgress").style.display = "block";
        const debugWindowRequested = !!el("enableDebugWindow")?.checked;
        pollTimer = setInterval(async () => {
          try {
            const job = await fetchJob(jobId);
            el("jobProgress").value = job.progress ?? 0;
            setStatus(`Status: ${job.status} | Stage: ${job.stage ?? "-"} | Progress: ${job.progress ?? 0}%`);
            // enable/disable cancel button
            const st = String(job.status || "");
            el("cancelBtn").disabled = !(st === "queued" || st === "running");
            // live trace (optional)
            if (debugWindowRequested) {
              try {
                const lt = await fetchLiveTrace(jobId);
                if (lt.enabled && lt.trace) {
                  el("liveTrace").style.display = "block";
                  renderLiveTrace(lt.trace);
                } else {
                  el("liveTrace").style.display = "none";
                  el("liveTraceBox").innerHTML = "";
                }
              } catch (e) {
                // ignore live-trace errors (debug disabled / race)
              }
            } else {
              el("liveTrace").style.display = "none";
              el("liveTraceBox").innerHTML = "";
            }
            if (job.status === "done") {
              clearInterval(pollTimer);
              const result = await fetchResult(jobId);
              renderResult(result);
              el("downloadBtn").disabled = false;
              el("cancelBtn").disabled = true;
              el("liveTrace").style.display = "none";
              el("liveTraceBox").innerHTML = "";
            }
            if (job.status === "failed" || job.status === "cancelled") {
              clearInterval(pollTimer);
              setStatus(`${job.status === "cancelled" ? "Cancelled" : "Failed"}: ${job.error || "Unknown error"}`);
              el("cancelBtn").disabled = true;
              el("liveTrace").style.display = "none";
              el("liveTraceBox").innerHTML = "";
            }
          } catch (e) {
            console.error(e);
          }
        }, 1200);
      }

      const MODEL_PRESETS = {
        nebius: [
          "Qwen/Qwen3-30B-A3B-Thinking-2507",
          "openai/gpt-oss-20b",
          "Qwen/Qwen2-7B-Instruct"
        ],
        openai: [
          "gpt-5-mini",
          "gpt-5-nano"
        ]
      };

      function setModelOptions(provider) {
        const sel = el("model");
        sel.innerHTML = "";
        const opts = (MODEL_PRESETS[provider] || []).slice();
        for (const m of opts) {
          const o = document.createElement("option");
          o.value = m;
          o.textContent = m;
          sel.appendChild(o);
        }
        if (provider === "nebius") sel.value = "Qwen/Qwen3-30B-A3B-Thinking-2507";
        if (provider === "openai") sel.value = "gpt-5-mini";
      }

      function updateProviderUI() {
        const p = el("provider").value || "nebius";
        el("baseUrlBox").style.display = (p === "nebius") ? "block" : "none";
        setModelOptions(p);
      }

      el("provider").addEventListener("change", updateProviderUI);
      updateProviderUI();

      el("uploadForm").addEventListener("submit", async (ev) => {
        ev.preventDefault();
        const file = el("pdfFile").files[0];
        if (!file) return;
        el("downloadBtn").disabled = true;
        el("cancelBtn").disabled = true;
        el("result").style.display = "none";
        setStatus("Uploading...");
        try {
          const data = await uploadPdf(file);
          currentJobId = data.job_id;
          el("jobInfo").textContent = `Job ID: ${currentJobId}`;
          setStatus(`Queued. Limits: pages<=${data.limits.max_pages}, paragraphs<=${data.limits.max_paragraphs}, file<=${data.limits.max_file_mb}MB`);
          el("cancelBtn").disabled = false;
          startPolling(currentJobId);
        } catch (e) {
          setStatus(String(e));
        }
      });

      el("cancelBtn").addEventListener("click", async () => {
        if (!currentJobId) return;
        el("cancelBtn").disabled = true;
        try {
          await cancelJob(currentJobId);
          setStatus("Cancelling...");
        } catch (e) {
          setStatus(String(e));
        }
      });

      el("downloadBtn").addEventListener("click", async () => {
        if (!currentJobId) return;
        const result = await fetchResult(currentJobId);
        const blob = new Blob([JSON.stringify(result, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `result_${currentJobId}.json`;
        a.click();
        URL.revokeObjectURL(url);
      });
    </script>
  </body>
</html>

